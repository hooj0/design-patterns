# 外观 `Facade`

| :sparkles:模式类型:sparkles::sparkles:|:sparkles::sparkles:难度:sparkles:  :sparkles: | :sparkles::sparkles:实用性:sparkles::sparkles: | :sparkles::sparkles:重要程度:sparkles::sparkles: |  :sparkles::sparkles:经典性:sparkles::sparkles: | :sparkles::sparkles:历史性:sparkles: |
| :----------------------------------------: | :-----------------------------------------------: | :-------------------------------------------------: | :----------------------------------------------------: | :--------------------------------------------------: | :--------------------------------------: |
|                 结构型模式                           |                ★★★★★ :arrow_down:                 |                  ★★★★★ :arrow_up:                   |                    ★★★★★ :arrow_up:                    |              :green_heart:  :arrow_up:               |        :green_heart:  :arrow_up:         |

## 概念
外观模式(`Facade Pattern`)：外部与一个子系统的通信必须通过一个**统一的外观对象**进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为**门面模式**，它是一种对象结构型模式。外观模式**隐藏系统的复杂性**，并向客户端提供了一个客户端可以访问系统的接口。这种模式涉及到一个单一的类，该类提供了**客户端请求的简化方法**和对现有系统类方法的**委托调用**。

## 用途
外观模式为子系统中的一组接口提供**统一接口**。外观模式定义了一个更高级别的接口，使子系统更易于使用。简单来说，外观模式为**复杂的子系统提供了简化的界面**。降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。


## 模式架构
根据“单一职责原则”，在软件中将一个系统划**分为若干个子系统**有利于**降低整个系统的复杂性**，一个常见的设计目标是使子系统间的**通信和相互依赖关系达到最小**，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个**简单而单一的入口**。 
- 外观模式的目的在于**降低系统的复杂程度**。外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以**降低原有系统的复杂度**，同时降低客户类与子系统类的**耦合度**。
- 外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。 
- 外观模式从很大程度上提高了客户端使用的**便捷性**，使得客户端**无须关心子系统的工作细节**，通过外观角色即可调用相关功能。


### 参与角色对象



### UML关系图



## 优点与缺点
+ **优点**
	+ 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。
	
+ **缺点**
	+ 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。

## 代码实现
外观模式的实现要点如下：
+ 1

### 示例参考
+ [外观模式](./java/io/github/hooj0/facade/)

## 应用场景
桥接模式适用于：
+ 为复杂的子系统**提供简单**的接口。子系统随着它们的发展变得越来越复杂。大多数模式在应用时会导致**更多更小**的类。这使得子系统更具**可重用性并且更易于定制**，但对于不需要自定义它的客户端也变得更难使用。外观可以提供子系统的简单默认视图，对大多数客户端来说足够好。只有需要更多可定制性的客户才需要超越外观。
+ 子系统相对独立：客户端和抽象的实现类之间存在许多依赖关系。引入外观以将子系统与客户端和其他子系统**分离**，从而提升子系统的**独立性和可移植性**。
+ 想分层你的子系统，定义系统的入口。使用外观来定义每个子系统级别的入口点。如果子系统是依赖的，那么你可以通过它们仅仅通过它们的外观相互通信来**简化它们之间的依赖关系**。
+ 预防低水平人员带来的风险

## 应用实例参考

### `JavaSDK` 
+ `java.lang.Class`
+ `javax.faces.webapp.FacesServlet`

### `GoSDK`

### `PythonSDK`

### `JavaScript Libs`



## 总结



## 参考资料





