# 外观 `Facade`

| :sparkles:模式类型:sparkles::sparkles:|:sparkles::sparkles:难度:sparkles:  :sparkles: | :sparkles::sparkles:实用性:sparkles::sparkles: | :sparkles::sparkles:重要程度:sparkles::sparkles: |  :sparkles::sparkles:经典性:sparkles::sparkles: | :sparkles::sparkles:历史性:sparkles: |
| :----------------------------------------: | :-----------------------------------------------: | :-------------------------------------------------: | :----------------------------------------------------: | :--------------------------------------------------: | :--------------------------------------: |
|                 结构型模式                           |                ★★★★★ :arrow_down:                 |                  ★★★★★ :arrow_up:                   |                    ★★★★★ :arrow_up:                    |              :green_heart:  :arrow_up:               |        :green_heart:  :arrow_up:         |

## 概念
外观模式(`Facade Pattern`)：外部与一个子系统的通信必须通过一个**统一的外观对象**进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为**门面模式**，它是一种对象结构型模式。外观模式**隐藏系统的复杂性**，并向客户端提供了一个客户端可以访问系统的接口。这种模式涉及到一个单一的类，该类提供了**客户端请求的简化方法**和对现有系统类方法的**委托调用**。

## 用途
外观模式为子系统中的一组接口提供**统一接口**。外观模式定义了一个更高级别的接口，使子系统更易于使用。简单来说，外观模式为**复杂的子系统提供了简化的界面**。


## 模式架构



### 参与角色对象



### UML关系图



## 优点与缺点
+ **优点**

+ **缺点**


## 代码实现
外观模式的实现要点如下：
+ 1

### 示例参考
+ [外观模式](./java/io/github/hooj0/facade/)

## 应用场景
桥接模式适用于：
+ 为复杂的子系统提供简单的接口。子系统随着它们的发展变得越来越复杂。大多数模式在应用时会导致更多更小的类。这使得子系统更具可重用性并且更易于定制，但对于不需要自定义它的客户端也变得更难使用。外观可以提供子系统的简单默认视图，对大多数客户端来说足够好。只有需要更多可定制性的客户才需要超越外观。
+ 客户端和抽象的实现类之间存在许多依赖关系。引入外观以将子系统与客户端和其他子系统分离，从而提升子系统的独立性和可移植性。
+ 你想分层你的子系统。使用外观来定义每个子系统级别的入口点。如果子系统是依赖的，那么你可以通过它们仅仅通过它们的外观相互通信来简化它们之间的依赖关系。

## 应用实例参考

### `JavaSDK` 
+ `java.lang.Class`
+ `javax.faces.webapp.FacesServlet`

### `GoSDK`

### `PythonSDK`

### `JavaScript Libs`



## 总结



## 参考资料





