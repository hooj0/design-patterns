# 抽象工厂 `Abstract Factory`

| :sparkles:模式类型:sparkles::sparkles:|:sparkles::sparkles:难度:sparkles:  :sparkles: | :sparkles::sparkles:实用性:sparkles::sparkles: | :sparkles::sparkles:重要程度:sparkles::sparkles: |  :sparkles::sparkles:经典性:sparkles::sparkles: | :sparkles::sparkles:历史性:sparkles: |
| :----------------------------------------: | :-----------------------------------------------: | :-------------------------------------------------: | :----------------------------------------------------: | :--------------------------------------------------: | :--------------------------------------: |
|              创造型模式                              |                ★★★★★ :arrow_down:                 |                  ★★★★★ :arrow_up:                   |                    ★★★★★ :arrow_up:                    |              :green_heart:  :arrow_up:               |        :green_heart:  :arrow_up:         |

## 概念
抽象工厂模式(`Abstract Factory`)，抽象工厂模式又称为`Kit`模式，属于**对象创建型**模式。抽象工厂是提供一个创建**一系列相关或相互依赖对象的接口，而无须指定它们具体的类**，接口是负责**创建**一个相关对象的工厂，**不需要显式**指定它们的类，每个生成的工厂都能**按照工厂模式提供对象**；抽象工厂**围绕一个超级工厂创建其他工厂，提供一个接口，用于创建相关的对象家族**。

## 用途
+ 抽象工厂主要**解决接口选择的问题**，它可以**创造一系列的工厂实例**让客户选择，通过**选择不同的工厂实例**可以**创建具体的产品**对象。在一个系统中，如果有**多套不同的产品**（产品族），而系统只**消费其中某一族**的产品，这个时候使用抽象工厂模式非常适合。
+ 在工厂方法中，**具体的工厂负责具体的产品的生产**，**每个工厂都会对应一个产品**。所以工厂方法**具有产品唯一性**，**一个工厂一般只提供一个方法实例化产品**。有时候我们需要**一个工厂能够生产多个产品**或是一个**超级产品中组成的很多小产品，而不是单一的产品**。
	- **产品等级结构**：产品的等级结构即产品的**继承结构**，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、`TCL`电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。
	- **产品簇**：在抽象模式中，产品簇即是**由同一个工厂生产**的，位于**不同产品等级结构中**的产品。如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。
+ 当系统所提供的工厂生产的产品并**不是一个简单的对象**，而是**多个位于不同产品等级结构**中的产品并且属于**不同类型的具体产品**，这时候需要使用工厂模式。
+ 抽象工厂模式是所有形式的工厂模式中**最为抽象和最具一般性**的一种形态。
+ 抽象工厂模式和工厂方法最大的区别：
	- 工厂方法是针对一种**特定的产品**的等级结构，它只生产一种**具体的产品**。
	- 抽象工厂则是**针对不同的产品等级结构**，是一个**产品簇**，它生产不同的**小产品组成的一套产品**。
	- 一个工厂等级结构可以**负责多个不同产品等级结构**中的产品对象的创建 。
	- 当一个工厂等级结构可以**创造分别属于不同产品等级结构**的一个**产品簇**中的所有对象时，**抽象工厂模式比工厂方法模式更简单、更有效率**。
	
+ 工厂方法模式**只有一个抽象产品类**，而**抽象工厂模式有多个**。   
+ 工厂方法模式的具体工厂类**只能创建一个具体产品类**的实例，而抽象工厂模式可以**创建多个**。
+ 工厂方法**创建 "一种" 产品**，他的着重点在于"**怎么创建**"，也就是说如果你开发，你的大量代码很可能围绕着这种**产品的构造**，**初始化**这些细节上面。也因为如此，类似的产品之间有很多可以**复用的特征**，所以会**和模板方法相随**。	

## 模式架构
抽象工厂方法**整合了工厂方法模式**，像是一个**更高级更大的工厂模式**，只不过抽象工厂产生的是**多个具体的工厂实例**，**每个工厂实例又可以实例化不同的具体工厂产品**。抽象工厂可以**生成一批不同的具体产品**。

### 参与角色对象
+ **`AbstractFactory` 工厂接口、工厂抽象类**：提供生产不同的产品工厂的抽象类
+ **`XxxConcreteFactory` 具体工厂，继承抽象工厂类**：将要生产产品的“工厂”的业务逻辑封装在工厂类而不对外暴露
+ **`AbstractProduct` 抽象产品、产品接口**：提供统一的产品定制模型，定制一套规范规格化的产品
+ **`XxxProduct` 具体产品**：提供构建不同的产品对象
  
### UML关系图
![1539420847067](../../../.images/1539420847067.png)


## 优点与缺点
+ **优点**
	- 当一个产品族中的**多个对象**被设计成一起工作时，它能**保证客户端始终只使用同一个产品族中的对象**。这对一些需要根据系统环境（如：系统数据源）来决定使用那一套产品来说，是一种非常实用的设计模式。
	- 抽象工厂模式**隔离了类的生成**，使得客户端无需知道类是如何生成的。由于这种隔离的**高内聚低耦合**的情况，使得**更换一个具体的工厂变动容易**。所有的具体工厂都实现了抽象工厂中定义的那些功能接口，因此只需用**改变具体的实例**，就可以**改变整个工厂的具体产品线**。
	- **增加新的具体工厂和产品族很方便**，无须修改已有系统，符合“**开闭原则**”。
	
+ **缺点**
	- 产品族**扩展非常困难**，要**增加一个系列**的某一产品，既要增加抽象的产品和产品的具体实现，有需要在抽象工厂中增加具体产品工厂，有需要完成抽象工厂的实现。
	- 在添加新的产品对象时，**难以扩展抽象工厂来生产新种类的产品**，这是因为在抽象工厂角色中规定了**所有可能被创建的产品集合**，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。
	- 开闭原则的倾斜性，增加新的工厂和产品族容易，**增加新的产品等级结构麻烦**。

## 代码实现
抽象工厂的实现要点如下：
+ 需要定义产品接口或抽象类`AbstractProduct`，定制需要实现产品的功能方法
+ 每个具体的产品`XxxProduct`需要实现产品接口或抽象类`AbstractProduct`，完成方法功能的实现
+ 定义工厂类`AbstractFactory`是一个抽象类，定义工厂的抽象方法，让具体的产品工厂去实现该方法返回工厂的实例
+ 工厂产品子类`XxxConcreteFactory`需要继承工厂类，利用`XxxProduct`完成产品工厂的创建实例化

### 示例参考
+ [抽象工厂](./java/io/github/hooj0/abstractfactory/)


## 应用场景
在一个系统中，如果**有多套不同的产品（产品族）**，而系统**只消费其中某一族**的产品，这个时候使用抽象工厂模式非常适合。大部分抽象工厂模式都是**一堆工厂方法**，每个工厂方法返回**某种类型**的对象。比如说工厂可以生产鼠标和键盘。那么抽象工厂的实现类（它的某个具体子类）的对象都可以生产鼠标和键盘，但可能工厂A生产的是罗技的键盘和鼠标，工厂B是微软的。

这样A和B就是工厂，对应于**抽象工厂**。每个工厂生产的鼠标和键盘就是**产品**，对应于工厂方法。用了工厂方法模式，你替换生成键盘的工厂方法，就可以把键盘从罗技换到微软。但是用了抽象工厂模式，你只要换家工厂，就可以同时替换鼠标和键盘一套。如果你要的产品有几十个，当然用**抽象工厂模式一次替换全部最方便**（这个工厂会替你用相应的工厂方法）所以说抽象工厂就像工厂，而工厂方法则像是工厂的一种产品生产线。


## 应用实例参考

### `JavaSDK` 
+ `java.util.Calendar#getInstance()`
+ `java.util.Arrays#asList()`
+ `java.util.ResourceBundle#getBundle()`
+ `java.sql.DriverManager#getConnection()`
+ `java.sql.Connection#createStatement()`
+ `java.sql.Statement#executeQuery()`
+ `java.text.NumberFormat#getInstance()`
+ `javax.xml.transform.TransformerFactory#newInstance()`

### `GoSDK`

### `PythonSDK`

### `JavaScript Libs`



## 总结

+ 抽象工厂是提供一个创建**一系列相关或相互依赖对象的接口，而无须指定它们具体的类**。抽象工厂围绕一个**超级工厂提供子工厂实例实现**，用于创建 相关的**对象家族**。
+ 抽象工厂方法可以说**整合了工厂方法模式**，像是一个**更高级更大的工厂模式**，只不过抽象工厂产生的是**多个具体的工厂实例**，每个工厂实例又可以**实例化不同的具体工厂产品**。抽象工厂可以**生成一批不同的产品工厂**，从而**生产不同的具体产品**。
+ 抽象工厂有四个核心的参与角色：**产品抽象类、具体产品实现、工厂抽象类、具体产品工厂实现**
+ 抽象工厂模式可以实现**高内聚低耦合**的设计目的，**增加新的具体工厂和产品族很方便**，无须修改已有系统，符合“**开闭原则**”。
+ 抽象工厂**扩展非常困难**，要增加产品族一系列的产品实现，还需要**修改具体的产品类**
+ 在一个系统中，如果有**多套不同的产品**（产品族），而**系统只消费其中某一族**的产品，这个时候使用抽象工厂模式非常适合。


## 参考资料





