# 设计模式设计原则

## 六大原则

+ 单一职责原则（`Single Responsibility Principle`）
+ 里氏代换原则（`Liskov Substitution Principle`）
+ 依赖倒置原则（`Dependence Inversion Principle`）
+ 接口隔离原则（`Interface Segregation Principle`）
+ 迪米特法则（`Demeter Principle`）
+ 开放/封闭原则（`Open Close Principle`）

## 适用于所有地方

+ [保持简单原则](#保持简单原则)
+ [YAGNI原则](#YAGNI原则)
+ [做最简单的事可能有效](#做最简单的事可能有效)
+ [关注点分离原则](#关注点分离)
+ [DRY原则](#DRY原则)
+ 维护者代码
+ 避免过早优化原则
+ 童子军原则

## 仅适用于模块内部/类

+ 最小化耦合
+ 得墨忒耳定律
+ 继承的组合
+ 正交
+ 稳健性原则
+ 控制反转

## 用于所有模块/类

+ 最大化凝聚力
+ 利斯科夫替代原则
+ 开放/封闭原则
+ 单一责任原则
+ 隐藏实施细节
+ 卷毛定律
+ 封装了哪些变化
+ 接口隔离原则
+ 命令查询分离

<hr/>

## 保持简单原则

如果保持简单而不是复杂，大多数系统都能发挥最佳性能。

### `Why?`

- 更少的代码花费更少的时间来编写，具有更少的错误，并且更容易修改。
- 简约是最终的完美。
- 似乎没有多余的东西可以达到完美，但是什么都没有留下来。

### 参考资源

- [保持简单原则](http://en.wikipedia.org/wiki/KISS_principle)
- [保持简单原则](http://principles-wiki.net/principles:keep_it_simple_stupid)

## YAGNI原则

YAGNI代表“你不会需要它”：在必要之前不要实现某些接口或方法。

### `Why?`

- 任何仅用于明天需要的功能的工作，意味着从当前迭代需要完成的功能中失去工作量。
- 它导致代码膨胀，软件变得更大，更复杂。

### `How?`

- 当你真正需要它们时，总是要实现它们，而不是在你预见到需要它们的时候。

### 参考资源

- [你不会需要它](http://c2.com/xp/YouArentGonnaNeedIt.html)
- [你不需要它！](http://www.xprogramming.com/Practices/PracNotNeed.html)
- [你不需要它](http://en.wikipedia.org/wiki/You_ain't_gonna_need_it)

## 做最简单的事可能有效

### `Why`

- 如果我们只是解决问题的真正原因，那么真正问题的真正进展就会最大化。

### `How`

- 问问自己：“最简单的事情是什么？”

### 参考资源

- [做最简单的事可能有效](http://c2.com/xp/DoTheSimplestThingThatCouldPossiblyWork.html)

## 关注点分离

关注点分离（`Soc`）是将计算机程序**分成不同部分**的设计原则，这样**每个部分都解决了一个单独的问题**。例如，应用程序的业务逻辑是一个问题，用户界面是另一个问题。更改用户界面不应要求更改业务逻辑，反之亦然。

### `Why`

- 简化软件应用程序的开发和维护。
- 当问题分离时，各个部分可以重复使用，也可以独立开发和更新。

### `How`

- 将程序功能分解为尽可能少重叠的单独模块。

### 参考资源

- [关注点分离](https://en.wikipedia.org/wiki/Separation_of_concerns)

## DRY原则

保持唯一原则，即`DRY`（`Don't repeat yourself `），字面意思来看："不要重复自己"。强调的意思就是在进行编程时相同的代码不要重复写，最好只写一次，然后可以在其他地方直接引用。如此一来，可以提高代码重用率，缩减代码量，同时也有助于提高代码的可读性和可维护性。当需要做出更改时，只需要更改一个地方即可。

每一条知识都必须在系统中具有单一、明确、权威的表示。程序中的每个重要功能都应该在源代码中的一个位置实现。在通过不同的代码片段执行类似的功能的情况下，通过**抽象出变化的部分**将它们组合成一个通常是有益的。

### `Why`

- 重复（无意或有目的的重复）可能导致维护噩梦，差的因素和逻辑矛盾。
- 对系统的任何单个元素的修改不需要改变其他逻辑上不相关的元素。
- 另外，逻辑上相关的元素都可以预测和统一地改变，因此保持同步。

### `How`

- 只在一个地方放置业务规则，长表达式，if语句，数学公式，元数据等。
- 确定系统中使用的每一条知识的单一，权威来源，然后使用该源生成该知识的适用实例（代码，文档，测试等）。
- 适用[三条规则](http://en.wikipedia.org/wiki/Rule_of_three_(computer_programming))。

### 参考资源

- [别重复自己](http://c2.com/cgi/wiki?DontRepeatYourself)
- [不要重复自己](http://en.wikipedia.org/wiki/Don't_repeat_yourself)
- [不要重复自己](http://programmer.97things.oreilly.com/wiki/index.php/Don't_Repeat_Yourself)

### 参考相关

- [抽象原则](http://en.wikipedia.org/wiki/Abstraction_principle_(computer_programming))
- [Once And Only Once](http://c2.com/cgi/wiki?OnceAndOnlyOnce)是DRY的一个子集（也称为重构的目标）。
- [单一真相来源](http://en.wikipedia.org/wiki/Single_Source_of_Truth)
- 违反DRY是[WET](http://thedailywtf.com/articles/The-WET-Cart)（写一切两次）