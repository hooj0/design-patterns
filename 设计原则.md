# 设计模式的设计原则

在程序设计中，程序的设计原则会帮助我们尽可能降低错误、工作量，提高程序的性能、开发效率。在某些情况下，设计程序需要根据当前程序进行一些规则的权衡选择。下面的设计原则并非绝对，仅仅是一个设计想法的参考，实际中的应用还需要考虑到众多因素，需要自己去权衡利弊进而选择适合自己的设计模式和原则。

## 六大原则

最常用的设计原则，也是目前比较被大众认可、统一固化的设计原则。

+ 单一职责原则（`Single Responsibility Principle`）
+ 里氏代换原则（`Liskov Substitution Principle`）
+ 依赖倒置原则（`Dependence Inversion Principle`）
+ 接口隔离原则（`Interface Segregation Principle`）
+ 迪米特法则（`Demeter Principle`）
+ 开放/封闭原则（`Open Close Principle`）

## 适用于所有地方

+ [保持简单原则](#保持简单原则)
+ [YAGNI原则](#yagni原则)
+ [做最简单的事可能有效](#做最简单的事可能有效)
+ [关注点分离原则](#关注点分离)
+ [DRY原则](#dry原则)
+ [维护者代码](singleton/readme.md)
+ 避免过早优化原则
+ 童子军原则

## 仅适用于模块内部/类

+ 最小化耦合
+ 得墨忒耳定律
+ 继承的组合
+ 正交
+ 稳健性原则
+ 控制反转

## 用于所有模块/类

+ 最大化凝聚力
+ 利斯科夫替代原则
+ 开放/封闭原则
+ 单一责任原则
+ 隐藏实施细节
+ 卷毛定律
+ 封装了哪些变化
+ 接口隔离原则
+ 命令查询分离

<hr/>

## 保持简单原则

如果**保持简单**而不是复杂，简单能让大多数系统都能发挥最佳性能，而复杂的程序让系统变得缓慢。

### `Why?`

- **更少的代码**花费**更少的时间**来编写，具有**更少的错误**，并且**更容易修改**。
- 简约是最终的完美。
- 似乎没有多余的东西，这样可以达到完美，不需要的什么都没有留下来。

### 参考资源

- [KISS principle](http://en.wikipedia.org/wiki/KISS_principle)
- [Keep It Simple Stupid (KISS)](http://principles-wiki.net/principles:keep_it_simple_stupid)

## YAGNI原则

YAGNI代表“你不会需要它”：在**必要**之前**不要实现某些接口或方法**。未来不明确需要的东西，不需要在当前完成它，但可以留下接口或扩展。因为未来是未知的变数，虽然在时间程序设计中，我们常常给未来做出很多看似明确的设计，但后期大部分都没有实现。

### `Why?`

- 任何仅用于明天需要的功能的工作，意味着从当前迭代需要完成的功能中失去工作量。
- 它导致代码膨胀，软件变得更大，更复杂。

### `How?`

- 当你真正需要它们时，总是要实现它们，而不是在你预见到需要它们的时候。

### 参考资源

- [You Arent Gonna Need It](http://c2.com/xp/YouArentGonnaNeedIt.html)
- [You’re NOT gonna need it!](http://www.xprogramming.com/Practices/PracNotNeed.html)
- [You ain't gonna need it](http://en.wikipedia.org/wiki/You_ain't_gonna_need_it)

## 做最简单的事可能有效

### `Why`

- 如果我们只是解决问题的真正原因，那么真正问题的真正进展就会最大化。

### `How`

- 问问自己：“最简单的事情是什么？”

### 参考资源

- [Do The Simplest Thing That Could Possibly Work](http://c2.com/xp/DoTheSimplestThingThatCouldPossiblyWork.html)

## 关注点分离

关注点分离（`Soc`）是将计算机程序**分成不同部分**的设计原则，这样**每个部分都解决了一个单独的问题**。例如，应用程序的业务逻辑是一个问题，用户界面是另一个问题。更改用户界面不应要求更改业务逻辑，反之亦然。

### `Why`

- 简化软件应用程序的开发和维护。
- 当问题分离时，各个部分可以重复使用，也可以独立开发和更新。

### `How`

- 将程序功能分解为尽可能少重叠的单独模块。

### 参考资源

- [Separation of Concerns](https://en.wikipedia.org/wiki/Separation_of_concerns)

## DRY原则

保持唯一原则，即`DRY`（`Don't repeat yourself `），字面意思来看："不要重复自己"。强调的意思就是在进行编程时相同的代码不要重复写，最好只写一次，然后可以在其他地方直接引用。如此一来，可以提高代码重用率，缩减代码量，同时也有助于提高代码的可读性和可维护性。当需要做出更改时，只需要更改一个地方即可。

每一条知识都必须在系统中具有单一、明确、权威的表示。程序中的每个重要功能都应该在源代码中的一个位置实现。在通过不同的代码片段执行类似的功能的情况下，通过**抽象出变化的部分**将它们组合成一个通常是有益的。

### `Why`

- 重复（无意或有目的的重复）可能导致维护噩梦，差的因素和逻辑矛盾。
- 对系统的任何单个元素的修改不需要改变其他逻辑上不相关的元素。
- 另外，逻辑上相关的元素都可以预测和统一地改变，因此保持同步。

### `How`

- 只在一个地方放置业务规则，长表达式，if语句，数学公式，元数据等。
- 确定系统中使用的每一条知识的单一，权威来源，然后使用该源生成该知识的适用实例（代码，文档，测试等）。
- 适用[三条规则](http://en.wikipedia.org/wiki/Rule_of_three_(computer_programming))。

### 参考资源

- [Dont Repeat Yourself](http://c2.com/cgi/wiki?DontRepeatYourself)
- [Don't repeat yourself](http://en.wikipedia.org/wiki/Don't_repeat_yourself)
- [Don't Repeat Yourself](http://programmer.97things.oreilly.com/wiki/index.php/Don't_Repeat_Yourself)

### 参考相关

- [抽象原则](http://en.wikipedia.org/wiki/Abstraction_principle_(computer_programming))
- [Once And Only Once](http://c2.com/cgi/wiki?OnceAndOnlyOnce)是DRY的一个子集（也称为重构的目标）。
- [单一真相来源](http://en.wikipedia.org/wiki/Single_Source_of_Truth)
- 违反DRY是[WET](http://thedailywtf.com/articles/The-WET-Cart)（一切写两次）

## 代码维护者

### `Whay?`

- 到目前为止，维护是任何项目中最昂贵的阶段。

### `How?`

- 做维护者。
- 总是编码好像最终维护你的代码的人是一个知道你住在哪里的暴力精神病患者。
- 总是以这样一种方式编码和评论：如果有人在少数几个级别上接受代码，他们会很乐意阅读并从中学习。
- [不要让我思考](http://www.sensible.com/dmmt.html)。
- 使用[最小惊讶原则](http://en.wikipedia.org/wiki/Principle_of_least_astonishment)。

资源

- [维护者代码](http://c2.com/cgi/wiki?CodeForTheMaintainer)
- [高尚的维护编程艺术](http://blog.codinghorror.com/the-noble-art-of-maintenance-programming/)



## 参考资料

http://java-design-patterns.com/principles/#interface-segregation-principle